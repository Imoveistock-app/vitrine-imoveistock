{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, isDevMode, Injectable, Inject, NgModule } from '@angular/core';\n/**\n * Represents a scrolling action\n */\n\nclass PageScrollInstance {\n  /**\n   * Private constructor, requires the properties assumed to be the bare minimum.\n   * Use the factory methods to create instances:\n   *      {@link PageScrollService#create}\n   */\n  constructor(pageScrollOptions) {\n    /**\n     * These properties will be set/manipulated if the scroll animation starts\n     */\n\n    /* The initial value of the scrollTop or scrollLeft position when the animation starts */\n    this.startScrollPosition = 0;\n    /* Whether an interrupt listener is attached to the body or not */\n\n    this.interruptListenersAttached = false;\n    /* References to the timer instance that is used to perform the scroll animation to be\n     able to clear it on animation end*/\n\n    this.timer = null;\n\n    if (!pageScrollOptions.scrollViews || pageScrollOptions.scrollViews.length === 0) {\n      pageScrollOptions.scrollViews = [pageScrollOptions.document.documentElement, pageScrollOptions.document.body, pageScrollOptions.document.body.parentNode];\n      this.isInlineScrolling = false;\n    } else {\n      this.isInlineScrolling = true;\n    }\n\n    this.pageScrollOptions = pageScrollOptions;\n  }\n\n  static getScrollingTargetPosition(pageScrollOptions, scrollTargetElement) {\n    const body = pageScrollOptions.document.body;\n    const docEl = pageScrollOptions.document.documentElement;\n    const windowPageYOffset = pageScrollOptions.document.defaultView && pageScrollOptions.document.defaultView.pageYOffset || undefined;\n    const windowPageXOffset = pageScrollOptions.document.defaultView && pageScrollOptions.document.defaultView.pageXOffset || undefined;\n    const scrollTop = windowPageYOffset || docEl.scrollTop || body.scrollTop;\n    const scrollLeft = windowPageXOffset || docEl.scrollLeft || body.scrollLeft;\n    const clientTop = docEl.clientTop || body.clientTop || 0;\n    const clientLeft = docEl.clientLeft || body.clientLeft || 0;\n\n    if (scrollTargetElement === undefined || scrollTargetElement === null) {\n      // No element found, so return the current position to not cause any change in scroll position\n      return {\n        top: scrollTop,\n        left: scrollLeft\n      };\n    }\n\n    const box = scrollTargetElement.getBoundingClientRect();\n    const top = box.top + scrollTop - clientTop;\n    const left = box.left + scrollLeft - clientLeft;\n    return {\n      top: Math.round(top),\n      left: Math.round(left)\n    };\n  }\n\n  static getInlineScrollingTargetPosition(pageScrollOptions, scrollTargetElement) {\n    const position = {\n      top: scrollTargetElement.offsetTop,\n      left: scrollTargetElement.offsetLeft\n    };\n\n    if (pageScrollOptions.advancedInlineOffsetCalculation && pageScrollOptions.scrollViews.length === 1) {\n      const accumulatedParentsPos = {\n        top: 0,\n        left: 0\n      }; // not named window to make sure we're not getting the global window variable by accident\n\n      const theWindow = scrollTargetElement.ownerDocument.defaultView;\n      let parentFound = false; // Start parent is the immediate parent\n\n      let parent = scrollTargetElement.parentElement; // Iterate upwards all parents\n\n      while (!parentFound && parent !== undefined && parent !== null) {\n        if (theWindow.getComputedStyle(parent).getPropertyValue('position') === 'relative') {\n          accumulatedParentsPos.top += parent.offsetTop;\n          accumulatedParentsPos.left += parent.offsetLeft;\n        } // Next iteration\n\n\n        parent = parent.parentElement;\n        parentFound = parent === pageScrollOptions.scrollViews[0];\n      }\n\n      if (parentFound) {\n        // Only use the results if we found the parent, otherwise we accumulated too much anyway\n        position.top += accumulatedParentsPos.top;\n        position.left += accumulatedParentsPos.left;\n      } else {\n        /* TODO Uncomment\n        if (PageScrollConfig._logLevel >= 2 || (PageScrollConfig._logLevel >= 1 && isDevMode())) {\n          console.warn('Unable to find nested scrolling targets parent!');\n        }*/\n      }\n    }\n\n    return position;\n  }\n\n  getScrollPropertyValue(scrollingView) {\n    if (!this.pageScrollOptions.verticalScrolling) {\n      return scrollingView.scrollLeft;\n    }\n\n    return scrollingView.scrollTop;\n  }\n\n  getScrollClientPropertyValue(scrollingView) {\n    if (!this.pageScrollOptions.verticalScrolling) {\n      return scrollingView.clientWidth;\n    }\n\n    return scrollingView.clientHeight;\n  }\n  /**\n   * Extract the exact location of the scrollTarget element.\n   *\n   * Extract the scrollTarget HTMLElement from the given PageScrollTarget object. The latter one may be\n   * a string like \"#heading2\", then this method returns the corresponding DOM element for that id.\n   *\n   */\n\n\n  extractScrollTargetPosition() {\n    const scrollTargetElement = this.getScrollTargetElement();\n\n    if (scrollTargetElement === null || scrollTargetElement === undefined) {\n      // Scroll target not found\n      return {\n        top: NaN,\n        left: NaN\n      };\n    }\n\n    if (this.isInlineScrolling) {\n      return PageScrollInstance.getInlineScrollingTargetPosition(this.pageScrollOptions, scrollTargetElement);\n    }\n\n    return PageScrollInstance.getScrollingTargetPosition(this.pageScrollOptions, scrollTargetElement);\n  }\n  /**\n   * Get the top offset of the scroll animation.\n   * This automatically takes the offset location of the scrolling container/scrolling view\n   * into account (for nested/inline scrolling).\n   */\n\n\n  getCurrentOffset() {\n    return this.pageScrollOptions.scrollOffset;\n  }\n  /**\n   * Sets the \"scrollTop\" or \"scrollLeft\" property for all scrollViews to the provided value\n   * @return true if at least for one ScrollTopSource the scrollTop/scrollLeft value could be set and it kept the new value.\n   *          false if it failed for all ScrollViews, meaning that we should stop the animation\n   *          (probably because we're at the end of the scrolling region)\n   */\n\n\n  setScrollPosition(position) {\n    // Set the new scrollTop/scrollLeft to all scrollViews elements\n    return this.pageScrollOptions.scrollViews.reduce((oneAlreadyWorked, scrollingView) => {\n      const startScrollPropertyValue = this.getScrollPropertyValue(scrollingView);\n\n      if (scrollingView && startScrollPropertyValue !== undefined && startScrollPropertyValue !== null) {\n        const scrollDistance = Math.abs(startScrollPropertyValue - position); // The movement we need to perform is less than 2px\n        // This we consider a small movement which some browser may not perform when\n        // changing the scrollTop/scrollLeft property\n        // Thus in this cases we do not stop the scroll animation, although setting the\n        // scrollTop/scrollLeft value \"fails\"\n\n        const isSmallMovement = scrollDistance < this.pageScrollOptions._minScrollDistance;\n\n        if (!this.pageScrollOptions.verticalScrolling) {\n          scrollingView.scrollLeft = position;\n        } else {\n          scrollingView.scrollTop = position;\n        } // Return true if setting the new scrollTop/scrollLeft value worked\n        // We consider that it worked if the new scrollTop/scrollLeft value is closer to the\n        // desired scrollTop/scrollLeft than before (it might not be exactly the value we\n        // set due to dpi or rounding irregularities)\n\n\n        if (isSmallMovement || scrollDistance > Math.abs(this.getScrollPropertyValue(scrollingView) - position)) {\n          return true;\n        }\n      }\n\n      return oneAlreadyWorked;\n    }, false);\n  }\n  /**\n   * Trigger firing a animation finish event\n   * @param value Whether the animation finished at the target (true) or got interrupted (false)\n   */\n\n\n  fireEvent(value) {\n    if (this.pageScrollOptions.scrollFinishListener) {\n      this.pageScrollOptions.scrollFinishListener.emit(value);\n    }\n  }\n  /**\n   * Attach the interrupt listeners to the PageScrollInstance body. The given interruptReporter\n   * will be called if any of the attached events is fired.\n   *\n   * Possibly attached interruptListeners are automatically removed from the body before the new one will be attached.\n   */\n\n\n  attachInterruptListeners(interruptReporter) {\n    if (this.interruptListenersAttached) {\n      // Detach possibly existing listeners first\n      this.detachInterruptListeners();\n    }\n\n    this.interruptListener = event => {\n      interruptReporter.report(event, this);\n    };\n\n    this.pageScrollOptions.interruptEvents.forEach(event => this.pageScrollOptions.document.body.addEventListener(event, this.interruptListener));\n    this.interruptListenersAttached = true;\n  }\n  /**\n   * Remove event listeners from the body and stop listening for events that might be treated as \"animation\n   * interrupt\" events.\n   */\n\n\n  detachInterruptListeners() {\n    this.pageScrollOptions.interruptEvents.forEach(event => this.pageScrollOptions.document.body.removeEventListener(event, this.interruptListener));\n    this.interruptListenersAttached = false;\n  }\n\n  getScrollTargetElement() {\n    if (typeof this.pageScrollOptions.scrollTarget === 'string') {\n      const targetSelector = this.pageScrollOptions.scrollTarget;\n\n      if (targetSelector.match(/^#[^\\s]+$/g) !== null) {\n        // It's an id selector and a valid id, as it does not contain any white space characters\n        return this.pageScrollOptions.document.getElementById(targetSelector.substr(1));\n      }\n\n      return this.pageScrollOptions.document.querySelector(targetSelector);\n    }\n\n    return this.pageScrollOptions.scrollTarget;\n  }\n\n}\n\nconst NGXPS_CONFIG = new InjectionToken('ngxps_config');\nconst defaultPageScrollConfig = {\n  _interval: 10,\n  _minScrollDistance: 2,\n  _logLevel: 1,\n  namespace: 'default',\n  verticalScrolling: true,\n  duration: 1250,\n  scrollOffset: 0,\n  advancedInlineOffsetCalculation: false,\n  interruptEvents: ['mousedown', 'wheel', 'DOMMouseScroll', 'mousewheel', 'keyup', 'touchmove'],\n  interruptKeys: [' ', 'Escape', 'Tab', 'Enter', 'PageUp', 'PageDown', 'Home', 'End', 'ArrowUp', 'ArrowRight', 'ArrowLeft', 'ArrowDown'],\n  interruptible: true,\n  scrollInView: true,\n  easingLogic: (t, b, c, d) => {\n    // Linear easing\n    return c * t / d + b;\n  }\n};\n\nclass PageScrollService {\n  constructor(customConfig) {\n    this.runningInstances = [];\n    this.onInterrupted = {\n      report: (event, pageScrollInstance) => {\n        if (!pageScrollInstance.pageScrollOptions.interruptible) {\n          // Non-interruptible anyway, so do not stop anything\n          return;\n        }\n\n        let shouldStop = true;\n\n        if (event.type === 'keyup') {\n          // Only stop if specific keys have been pressed, for all others don't stop anything\n          if (this.config.interruptKeys.indexOf(event.key) === -1) {\n            // The pressed key is not in the list of interrupting keys\n            shouldStop = false;\n          }\n        } else if (event.type === 'mousedown') {\n          // For mousedown events we only stop the scroll animation of the mouse has\n          // been clicked inside the scrolling container\n          if (!pageScrollInstance.pageScrollOptions.scrollViews.some(scrollingView => scrollingView.contains(event.target))) {\n            // Mouse clicked an element which is not inside any of the the scrolling containers\n            shouldStop = false;\n          }\n        }\n\n        if (shouldStop) {\n          this.stopAll(pageScrollInstance.pageScrollOptions.namespace);\n        }\n      }\n    };\n    this.config = { ...defaultPageScrollConfig,\n      ...customConfig\n    };\n  }\n\n  stopInternal(interrupted, pageScrollInstance) {\n    const index = this.runningInstances.indexOf(pageScrollInstance);\n\n    if (index >= 0) {\n      this.runningInstances.splice(index, 1);\n    }\n\n    if (pageScrollInstance.interruptListenersAttached) {\n      pageScrollInstance.detachInterruptListeners();\n    }\n\n    if (pageScrollInstance.timer) {\n      // Clear/Stop the timer\n      clearInterval(pageScrollInstance.timer); // Clear the reference to this timer\n\n      pageScrollInstance.timer = undefined;\n      pageScrollInstance.fireEvent(!interrupted);\n      return true;\n    }\n\n    return false;\n  }\n\n  create(options) {\n    return new PageScrollInstance({ ...this.config,\n      ...options\n    });\n  }\n  /**\n   * Start a scroll animation. All properties of the animation are stored in the given {@link PageScrollInstance} object.\n   *\n   * This is the core functionality of the whole library.\n   */\n  // tslint:disable-next-line:cyclomatic-complexity\n\n\n  start(pageScrollInstance) {\n    // Merge the default options in the pageScrollInstance options\n    pageScrollInstance.pageScrollOptions = { ...this.config,\n      ...pageScrollInstance.pageScrollOptions\n    }; // Stop all possibly running scroll animations in the same namespace\n\n    this.stopAll(pageScrollInstance.pageScrollOptions.namespace);\n\n    if (pageScrollInstance.pageScrollOptions.scrollViews === null || pageScrollInstance.pageScrollOptions.scrollViews.length === 0) {\n      // No scrollViews specified, thus we can't animate anything\n      if (this.config._logLevel >= 2 || this.config._logLevel >= 1 && isDevMode()) {\n        console.warn('No scrollViews specified, thus ngx-page-scroll does not know which DOM elements to scroll');\n      }\n\n      return;\n    }\n\n    let startScrollPositionFound = false;\n    let scrollRange = pageScrollInstance.getScrollClientPropertyValue(pageScrollInstance.pageScrollOptions.scrollViews[0]); // Reset start scroll position to 0. If any of the scrollViews has a different one, it will be extracted next\n\n    pageScrollInstance.startScrollPosition = 0; // Get the start scroll position from the scrollViews (e.g. if the user already scrolled down the content)\n\n    pageScrollInstance.pageScrollOptions.scrollViews.forEach(scrollingView => {\n      if (scrollingView === undefined || scrollingView === null) {\n        return;\n      } // Get the scrollTop or scrollLeft value of the first scrollingView that returns a value for its \"scrollTop\"\n      // or \"scrollLeft\" property that is not undefined and unequal to 0\n\n\n      const scrollPosition = pageScrollInstance.getScrollPropertyValue(scrollingView);\n\n      if (!startScrollPositionFound && scrollPosition) {\n        // We found a scrollingView that does not have scrollTop or scrollLeft 0\n        // Return the scroll position value, as this will be our startScrollPosition\n        pageScrollInstance.startScrollPosition = scrollPosition;\n        startScrollPositionFound = true; // Remember te scrollRange of this scrollingView\n\n        scrollRange = pageScrollInstance.getScrollClientPropertyValue(scrollingView);\n      }\n    });\n    const pageScrollOffset = pageScrollInstance.getCurrentOffset(); // Calculate the target position that the scroll animation should go to\n\n    const scrollTargetPosition = pageScrollInstance.extractScrollTargetPosition();\n    pageScrollInstance.targetScrollPosition = Math.round((pageScrollInstance.pageScrollOptions.verticalScrolling ? scrollTargetPosition.top : scrollTargetPosition.left) - pageScrollOffset); // Calculate the distance we need to go in total\n\n    pageScrollInstance.distanceToScroll = pageScrollInstance.targetScrollPosition - pageScrollInstance.startScrollPosition;\n\n    if (isNaN(pageScrollInstance.distanceToScroll)) {\n      // We weren't able to find the target position, maybe the element does not exist?\n      if (this.config._logLevel >= 2 || this.config._logLevel >= 1 && isDevMode()) {\n        console.log('Scrolling not possible, as we can\\'t find the specified target');\n      }\n\n      pageScrollInstance.fireEvent(false);\n      return;\n    } // We're at the final destination already\n    // OR we need to scroll down but are already at the end\n    // OR we need to scroll up but are at the top already\n\n\n    const allReadyAtDestination = Math.abs(pageScrollInstance.distanceToScroll) < pageScrollInstance.pageScrollOptions._minScrollDistance; // Check how long we need to scroll if a speed option is given\n    // Default executionDuration is the specified duration\n\n\n    pageScrollInstance.executionDuration = pageScrollInstance.pageScrollOptions.duration; // Maybe we need to pay attention to the speed option?\n\n    if (pageScrollInstance.pageScrollOptions.speed !== undefined && pageScrollInstance.pageScrollOptions.speed !== null && (pageScrollInstance.pageScrollOptions.duration === undefined || pageScrollInstance.pageScrollOptions.duration === null)) {\n      // Speed option is set and no duration => calculate duration based on speed and scroll distance\n      pageScrollInstance.executionDuration = Math.abs(pageScrollInstance.distanceToScroll) / pageScrollInstance.pageScrollOptions.speed * 1000;\n    } // We should go there directly, as our \"animation\" would have one big step\n    // only anyway and this way we save the interval stuff\n\n\n    const tooShortInterval = pageScrollInstance.executionDuration <= pageScrollInstance.pageScrollOptions._interval;\n\n    if (allReadyAtDestination || tooShortInterval) {\n      if (this.config._logLevel >= 2 || this.config._logLevel >= 1 && isDevMode()) {\n        if (allReadyAtDestination) {\n          console.log('Scrolling not possible, as we can\\'t get any closer to the destination');\n        } else {\n          console.log('Scroll duration shorter that interval length, jumping to target');\n        }\n      }\n\n      pageScrollInstance.setScrollPosition(pageScrollInstance.targetScrollPosition);\n      pageScrollInstance.fireEvent(true);\n      return;\n    }\n\n    if (!pageScrollInstance.pageScrollOptions.scrollInView) {\n      const alreadyInView = pageScrollInstance.targetScrollPosition > pageScrollInstance.startScrollPosition && pageScrollInstance.targetScrollPosition <= pageScrollInstance.startScrollPosition + scrollRange;\n\n      if (alreadyInView) {\n        if (this.config._logLevel >= 2 || this.config._logLevel >= 1 && isDevMode()) {\n          console.log('Not scrolling, as target already in view');\n        }\n\n        pageScrollInstance.fireEvent(true);\n        return;\n      }\n    } // Register the interrupt listeners if we want an interruptible scroll animation\n\n\n    if (pageScrollInstance.pageScrollOptions.interruptible) {\n      pageScrollInstance.attachInterruptListeners(this.onInterrupted);\n    } // Let's get started, get the start time...\n\n\n    pageScrollInstance.startTime = new Date().getTime(); // .. and calculate the end time (when we need to finish at last)\n\n    pageScrollInstance.endTime = pageScrollInstance.startTime + pageScrollInstance.executionDuration;\n    pageScrollInstance.timer = setInterval(instance => {\n      // Take the current time\n      const currentTime = new Date().getTime(); // Determine the new scroll position\n\n      let newScrollPosition;\n      let stopNow = false;\n\n      if (instance.endTime <= currentTime) {\n        // We're over the time already, so go the targetScrollPosition (aka destination)\n        newScrollPosition = instance.targetScrollPosition;\n        stopNow = true;\n      } else {\n        // Calculate the scroll position based on the current time using the easing function\n        newScrollPosition = Math.round(instance.pageScrollOptions.easingLogic(currentTime - instance.startTime, instance.startScrollPosition, instance.distanceToScroll, instance.executionDuration));\n      }\n\n      if (this.config._logLevel >= 5 && isDevMode()) {\n        console.warn('Scroll Position: ' + newScrollPosition);\n      } // Set the new scrollPosition to all scrollViews elements\n\n\n      if (!instance.setScrollPosition(newScrollPosition)) {\n        // Setting the new scrollTop/scrollLeft value failed for all ScrollViews\n        // early stop the scroll animation to save resources\n        stopNow = true;\n      } // At the end do the internal stop maintenance and fire the pageScrollFinish event\n      // (otherwise the event might arrive at \"too early\")\n\n\n      if (stopNow) {\n        this.stopInternal(false, instance);\n      }\n    }, this.config._interval, pageScrollInstance); // Register the instance as running one\n\n    this.runningInstances.push(pageScrollInstance);\n  }\n\n  scroll(options) {\n    this.start(this.create(options));\n  }\n  /**\n   * Stop all running scroll animations. Optionally limit to stop only the ones of specific namespace.\n   */\n\n\n  stopAll(namespace) {\n    if (this.runningInstances.length > 0) {\n      let stoppedSome = false;\n\n      for (let i = 0; i < this.runningInstances.length; ++i) {\n        const pageScrollInstance = this.runningInstances[i];\n\n        if (!namespace || pageScrollInstance.pageScrollOptions.namespace === namespace) {\n          stoppedSome = true;\n          this.stopInternal(true, pageScrollInstance); // Decrease the counter, as we removed an item from the array we iterate over\n\n          i--;\n        }\n      }\n\n      return stoppedSome;\n    }\n\n    return false;\n  }\n\n  stop(pageScrollInstance) {\n    return this.stopInternal(true, pageScrollInstance);\n  }\n\n}\n\nPageScrollService.ɵfac = function PageScrollService_Factory(t) {\n  return new (t || PageScrollService)(i0.ɵɵinject(NGXPS_CONFIG));\n};\n\nPageScrollService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PageScrollService,\n  factory: PageScrollService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PageScrollService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [NGXPS_CONFIG]\n      }]\n    }];\n  }, null);\n})();\n\nclass NgxPageScrollCoreModule {\n  static forRoot(config) {\n    return {\n      ngModule: NgxPageScrollCoreModule,\n      providers: [PageScrollService, {\n        provide: NGXPS_CONFIG,\n        useValue: config\n      }]\n    };\n  }\n\n}\n\nNgxPageScrollCoreModule.ɵfac = function NgxPageScrollCoreModule_Factory(t) {\n  return new (t || NgxPageScrollCoreModule)();\n};\n\nNgxPageScrollCoreModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxPageScrollCoreModule\n});\nNgxPageScrollCoreModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  providers: [PageScrollService, {\n    provide: NGXPS_CONFIG,\n    useValue: {}\n  }]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPageScrollCoreModule, [{\n    type: NgModule,\n    args: [{\n      providers: [PageScrollService, {\n        provide: NGXPS_CONFIG,\n        useValue: {}\n      }]\n    }]\n  }], null, null);\n})();\n/*\n * Public API Surface of ngx-page-scroll-core\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NGXPS_CONFIG, NgxPageScrollCoreModule, PageScrollInstance, PageScrollService, defaultPageScrollConfig };","map":{"version":3,"names":["i0","InjectionToken","isDevMode","Injectable","Inject","NgModule","PageScrollInstance","constructor","pageScrollOptions","startScrollPosition","interruptListenersAttached","timer","scrollViews","length","document","documentElement","body","parentNode","isInlineScrolling","getScrollingTargetPosition","scrollTargetElement","docEl","windowPageYOffset","defaultView","pageYOffset","undefined","windowPageXOffset","pageXOffset","scrollTop","scrollLeft","clientTop","clientLeft","top","left","box","getBoundingClientRect","Math","round","getInlineScrollingTargetPosition","position","offsetTop","offsetLeft","advancedInlineOffsetCalculation","accumulatedParentsPos","theWindow","ownerDocument","parentFound","parent","parentElement","getComputedStyle","getPropertyValue","getScrollPropertyValue","scrollingView","verticalScrolling","getScrollClientPropertyValue","clientWidth","clientHeight","extractScrollTargetPosition","getScrollTargetElement","NaN","getCurrentOffset","scrollOffset","setScrollPosition","reduce","oneAlreadyWorked","startScrollPropertyValue","scrollDistance","abs","isSmallMovement","_minScrollDistance","fireEvent","value","scrollFinishListener","emit","attachInterruptListeners","interruptReporter","detachInterruptListeners","interruptListener","event","report","interruptEvents","forEach","addEventListener","removeEventListener","scrollTarget","targetSelector","match","getElementById","substr","querySelector","NGXPS_CONFIG","defaultPageScrollConfig","_interval","_logLevel","namespace","duration","interruptKeys","interruptible","scrollInView","easingLogic","t","b","c","d","PageScrollService","customConfig","runningInstances","onInterrupted","pageScrollInstance","shouldStop","type","config","indexOf","key","some","contains","target","stopAll","stopInternal","interrupted","index","splice","clearInterval","create","options","start","console","warn","startScrollPositionFound","scrollRange","scrollPosition","pageScrollOffset","scrollTargetPosition","targetScrollPosition","distanceToScroll","isNaN","log","allReadyAtDestination","executionDuration","speed","tooShortInterval","alreadyInView","startTime","Date","getTime","endTime","setInterval","instance","currentTime","newScrollPosition","stopNow","push","scroll","stoppedSome","i","stop","ɵfac","ɵprov","args","providedIn","decorators","NgxPageScrollCoreModule","forRoot","ngModule","providers","provide","useValue","ɵmod","ɵinj"],"sources":["C:/Users/infer/OneDrive/Documentos/GitHub/landing-page-imoveistock/node_modules/ngx-page-scroll-core/fesm2020/ngx-page-scroll-core.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, isDevMode, Injectable, Inject, NgModule } from '@angular/core';\n\n/**\n * Represents a scrolling action\n */\nclass PageScrollInstance {\n    /**\n     * Private constructor, requires the properties assumed to be the bare minimum.\n     * Use the factory methods to create instances:\n     *      {@link PageScrollService#create}\n     */\n    constructor(pageScrollOptions) {\n        /**\n         * These properties will be set/manipulated if the scroll animation starts\n         */\n        /* The initial value of the scrollTop or scrollLeft position when the animation starts */\n        this.startScrollPosition = 0;\n        /* Whether an interrupt listener is attached to the body or not */\n        this.interruptListenersAttached = false;\n        /* References to the timer instance that is used to perform the scroll animation to be\n         able to clear it on animation end*/\n        this.timer = null;\n        if (!pageScrollOptions.scrollViews || pageScrollOptions.scrollViews.length === 0) {\n            pageScrollOptions.scrollViews = [\n                pageScrollOptions.document.documentElement,\n                pageScrollOptions.document.body,\n                pageScrollOptions.document.body.parentNode,\n            ];\n            this.isInlineScrolling = false;\n        }\n        else {\n            this.isInlineScrolling = true;\n        }\n        this.pageScrollOptions = pageScrollOptions;\n    }\n    static getScrollingTargetPosition(pageScrollOptions, scrollTargetElement) {\n        const body = pageScrollOptions.document.body;\n        const docEl = pageScrollOptions.document.documentElement;\n        const windowPageYOffset = pageScrollOptions.document.defaultView &&\n            pageScrollOptions.document.defaultView.pageYOffset || undefined;\n        const windowPageXOffset = pageScrollOptions.document.defaultView &&\n            pageScrollOptions.document.defaultView.pageXOffset || undefined;\n        const scrollTop = windowPageYOffset || docEl.scrollTop || body.scrollTop;\n        const scrollLeft = windowPageXOffset || docEl.scrollLeft || body.scrollLeft;\n        const clientTop = docEl.clientTop || body.clientTop || 0;\n        const clientLeft = docEl.clientLeft || body.clientLeft || 0;\n        if (scrollTargetElement === undefined || scrollTargetElement === null) {\n            // No element found, so return the current position to not cause any change in scroll position\n            return { top: scrollTop, left: scrollLeft };\n        }\n        const box = scrollTargetElement.getBoundingClientRect();\n        const top = box.top + scrollTop - clientTop;\n        const left = box.left + scrollLeft - clientLeft;\n        return { top: Math.round(top), left: Math.round(left) };\n    }\n    static getInlineScrollingTargetPosition(pageScrollOptions, scrollTargetElement) {\n        const position = { top: scrollTargetElement.offsetTop, left: scrollTargetElement.offsetLeft };\n        if (pageScrollOptions.advancedInlineOffsetCalculation && pageScrollOptions.scrollViews.length === 1) {\n            const accumulatedParentsPos = { top: 0, left: 0 };\n            // not named window to make sure we're not getting the global window variable by accident\n            const theWindow = scrollTargetElement.ownerDocument.defaultView;\n            let parentFound = false;\n            // Start parent is the immediate parent\n            let parent = scrollTargetElement.parentElement;\n            // Iterate upwards all parents\n            while (!parentFound && parent !== undefined && parent !== null) {\n                if (theWindow.getComputedStyle(parent).getPropertyValue('position') === 'relative') {\n                    accumulatedParentsPos.top += parent.offsetTop;\n                    accumulatedParentsPos.left += parent.offsetLeft;\n                }\n                // Next iteration\n                parent = parent.parentElement;\n                parentFound = parent === pageScrollOptions.scrollViews[0];\n            }\n            if (parentFound) {\n                // Only use the results if we found the parent, otherwise we accumulated too much anyway\n                position.top += accumulatedParentsPos.top;\n                position.left += accumulatedParentsPos.left;\n            }\n            else {\n                /* TODO Uncomment\n                if (PageScrollConfig._logLevel >= 2 || (PageScrollConfig._logLevel >= 1 && isDevMode())) {\n                  console.warn('Unable to find nested scrolling targets parent!');\n                }*/\n            }\n        }\n        return position;\n    }\n    getScrollPropertyValue(scrollingView) {\n        if (!this.pageScrollOptions.verticalScrolling) {\n            return scrollingView.scrollLeft;\n        }\n        return scrollingView.scrollTop;\n    }\n    getScrollClientPropertyValue(scrollingView) {\n        if (!this.pageScrollOptions.verticalScrolling) {\n            return scrollingView.clientWidth;\n        }\n        return scrollingView.clientHeight;\n    }\n    /**\n     * Extract the exact location of the scrollTarget element.\n     *\n     * Extract the scrollTarget HTMLElement from the given PageScrollTarget object. The latter one may be\n     * a string like \"#heading2\", then this method returns the corresponding DOM element for that id.\n     *\n     */\n    extractScrollTargetPosition() {\n        const scrollTargetElement = this.getScrollTargetElement();\n        if (scrollTargetElement === null || scrollTargetElement === undefined) {\n            // Scroll target not found\n            return { top: NaN, left: NaN };\n        }\n        if (this.isInlineScrolling) {\n            return PageScrollInstance.getInlineScrollingTargetPosition(this.pageScrollOptions, scrollTargetElement);\n        }\n        return PageScrollInstance.getScrollingTargetPosition(this.pageScrollOptions, scrollTargetElement);\n    }\n    /**\n     * Get the top offset of the scroll animation.\n     * This automatically takes the offset location of the scrolling container/scrolling view\n     * into account (for nested/inline scrolling).\n     */\n    getCurrentOffset() {\n        return this.pageScrollOptions.scrollOffset;\n    }\n    /**\n     * Sets the \"scrollTop\" or \"scrollLeft\" property for all scrollViews to the provided value\n     * @return true if at least for one ScrollTopSource the scrollTop/scrollLeft value could be set and it kept the new value.\n     *          false if it failed for all ScrollViews, meaning that we should stop the animation\n     *          (probably because we're at the end of the scrolling region)\n     */\n    setScrollPosition(position) {\n        // Set the new scrollTop/scrollLeft to all scrollViews elements\n        return this.pageScrollOptions.scrollViews.reduce((oneAlreadyWorked, scrollingView) => {\n            const startScrollPropertyValue = this.getScrollPropertyValue(scrollingView);\n            if (scrollingView && startScrollPropertyValue !== undefined && startScrollPropertyValue !== null) {\n                const scrollDistance = Math.abs(startScrollPropertyValue - position);\n                // The movement we need to perform is less than 2px\n                // This we consider a small movement which some browser may not perform when\n                // changing the scrollTop/scrollLeft property\n                // Thus in this cases we do not stop the scroll animation, although setting the\n                // scrollTop/scrollLeft value \"fails\"\n                const isSmallMovement = scrollDistance < this.pageScrollOptions._minScrollDistance;\n                if (!this.pageScrollOptions.verticalScrolling) {\n                    scrollingView.scrollLeft = position;\n                }\n                else {\n                    scrollingView.scrollTop = position;\n                }\n                // Return true if setting the new scrollTop/scrollLeft value worked\n                // We consider that it worked if the new scrollTop/scrollLeft value is closer to the\n                // desired scrollTop/scrollLeft than before (it might not be exactly the value we\n                // set due to dpi or rounding irregularities)\n                if (isSmallMovement || scrollDistance > Math.abs(this.getScrollPropertyValue(scrollingView) - position)) {\n                    return true;\n                }\n            }\n            return oneAlreadyWorked;\n        }, false);\n    }\n    /**\n     * Trigger firing a animation finish event\n     * @param value Whether the animation finished at the target (true) or got interrupted (false)\n     */\n    fireEvent(value) {\n        if (this.pageScrollOptions.scrollFinishListener) {\n            this.pageScrollOptions.scrollFinishListener.emit(value);\n        }\n    }\n    /**\n     * Attach the interrupt listeners to the PageScrollInstance body. The given interruptReporter\n     * will be called if any of the attached events is fired.\n     *\n     * Possibly attached interruptListeners are automatically removed from the body before the new one will be attached.\n     */\n    attachInterruptListeners(interruptReporter) {\n        if (this.interruptListenersAttached) {\n            // Detach possibly existing listeners first\n            this.detachInterruptListeners();\n        }\n        this.interruptListener = (event) => {\n            interruptReporter.report(event, this);\n        };\n        this.pageScrollOptions.interruptEvents.forEach((event) => this.pageScrollOptions.document.body.addEventListener(event, this.interruptListener));\n        this.interruptListenersAttached = true;\n    }\n    /**\n     * Remove event listeners from the body and stop listening for events that might be treated as \"animation\n     * interrupt\" events.\n     */\n    detachInterruptListeners() {\n        this.pageScrollOptions.interruptEvents.forEach((event) => this.pageScrollOptions.document.body.removeEventListener(event, this.interruptListener));\n        this.interruptListenersAttached = false;\n    }\n    getScrollTargetElement() {\n        if (typeof this.pageScrollOptions.scrollTarget === 'string') {\n            const targetSelector = this.pageScrollOptions.scrollTarget;\n            if (targetSelector.match(/^#[^\\s]+$/g) !== null) {\n                // It's an id selector and a valid id, as it does not contain any white space characters\n                return this.pageScrollOptions.document.getElementById(targetSelector.substr(1));\n            }\n            return this.pageScrollOptions.document.querySelector(targetSelector);\n        }\n        return this.pageScrollOptions.scrollTarget;\n    }\n}\n\nconst NGXPS_CONFIG = new InjectionToken('ngxps_config');\nconst defaultPageScrollConfig = {\n    _interval: 10,\n    _minScrollDistance: 2,\n    _logLevel: 1,\n    namespace: 'default',\n    verticalScrolling: true,\n    duration: 1250,\n    scrollOffset: 0,\n    advancedInlineOffsetCalculation: false,\n    interruptEvents: ['mousedown', 'wheel', 'DOMMouseScroll', 'mousewheel', 'keyup', 'touchmove'],\n    interruptKeys: [' ', 'Escape', 'Tab', 'Enter', 'PageUp', 'PageDown', 'Home', 'End', 'ArrowUp', 'ArrowRight', 'ArrowLeft', 'ArrowDown'],\n    interruptible: true,\n    scrollInView: true,\n    easingLogic: (t, b, c, d) => {\n        // Linear easing\n        return c * t / d + b;\n    },\n};\n\nclass PageScrollService {\n    constructor(customConfig) {\n        this.runningInstances = [];\n        this.onInterrupted = {\n            report: (event, pageScrollInstance) => {\n                if (!pageScrollInstance.pageScrollOptions.interruptible) {\n                    // Non-interruptible anyway, so do not stop anything\n                    return;\n                }\n                let shouldStop = true;\n                if (event.type === 'keyup') {\n                    // Only stop if specific keys have been pressed, for all others don't stop anything\n                    if (this.config.interruptKeys.indexOf(event.key) === -1) {\n                        // The pressed key is not in the list of interrupting keys\n                        shouldStop = false;\n                    }\n                }\n                else if (event.type === 'mousedown') {\n                    // For mousedown events we only stop the scroll animation of the mouse has\n                    // been clicked inside the scrolling container\n                    if (!pageScrollInstance.pageScrollOptions.scrollViews.some(scrollingView => scrollingView.contains(event.target))) {\n                        // Mouse clicked an element which is not inside any of the the scrolling containers\n                        shouldStop = false;\n                    }\n                }\n                if (shouldStop) {\n                    this.stopAll(pageScrollInstance.pageScrollOptions.namespace);\n                }\n            },\n        };\n        this.config = { ...defaultPageScrollConfig, ...customConfig };\n    }\n    stopInternal(interrupted, pageScrollInstance) {\n        const index = this.runningInstances.indexOf(pageScrollInstance);\n        if (index >= 0) {\n            this.runningInstances.splice(index, 1);\n        }\n        if (pageScrollInstance.interruptListenersAttached) {\n            pageScrollInstance.detachInterruptListeners();\n        }\n        if (pageScrollInstance.timer) {\n            // Clear/Stop the timer\n            clearInterval(pageScrollInstance.timer);\n            // Clear the reference to this timer\n            pageScrollInstance.timer = undefined;\n            pageScrollInstance.fireEvent(!interrupted);\n            return true;\n        }\n        return false;\n    }\n    create(options) {\n        return new PageScrollInstance({ ...this.config, ...options });\n    }\n    /**\n     * Start a scroll animation. All properties of the animation are stored in the given {@link PageScrollInstance} object.\n     *\n     * This is the core functionality of the whole library.\n     */\n    // tslint:disable-next-line:cyclomatic-complexity\n    start(pageScrollInstance) {\n        // Merge the default options in the pageScrollInstance options\n        pageScrollInstance.pageScrollOptions = { ...this.config, ...pageScrollInstance.pageScrollOptions };\n        // Stop all possibly running scroll animations in the same namespace\n        this.stopAll(pageScrollInstance.pageScrollOptions.namespace);\n        if (pageScrollInstance.pageScrollOptions.scrollViews === null || pageScrollInstance.pageScrollOptions.scrollViews.length === 0) {\n            // No scrollViews specified, thus we can't animate anything\n            if (this.config._logLevel >= 2 || (this.config._logLevel >= 1 && isDevMode())) {\n                console.warn('No scrollViews specified, thus ngx-page-scroll does not know which DOM elements to scroll');\n            }\n            return;\n        }\n        let startScrollPositionFound = false;\n        let scrollRange = pageScrollInstance.getScrollClientPropertyValue(pageScrollInstance.pageScrollOptions.scrollViews[0]);\n        // Reset start scroll position to 0. If any of the scrollViews has a different one, it will be extracted next\n        pageScrollInstance.startScrollPosition = 0;\n        // Get the start scroll position from the scrollViews (e.g. if the user already scrolled down the content)\n        pageScrollInstance.pageScrollOptions.scrollViews.forEach(scrollingView => {\n            if (scrollingView === undefined || scrollingView === null) {\n                return;\n            }\n            // Get the scrollTop or scrollLeft value of the first scrollingView that returns a value for its \"scrollTop\"\n            // or \"scrollLeft\" property that is not undefined and unequal to 0\n            const scrollPosition = pageScrollInstance.getScrollPropertyValue(scrollingView);\n            if (!startScrollPositionFound && scrollPosition) {\n                // We found a scrollingView that does not have scrollTop or scrollLeft 0\n                // Return the scroll position value, as this will be our startScrollPosition\n                pageScrollInstance.startScrollPosition = scrollPosition;\n                startScrollPositionFound = true;\n                // Remember te scrollRange of this scrollingView\n                scrollRange = pageScrollInstance.getScrollClientPropertyValue(scrollingView);\n            }\n        });\n        const pageScrollOffset = pageScrollInstance.getCurrentOffset();\n        // Calculate the target position that the scroll animation should go to\n        const scrollTargetPosition = pageScrollInstance.extractScrollTargetPosition();\n        pageScrollInstance.targetScrollPosition = Math.round((pageScrollInstance.pageScrollOptions.verticalScrolling ? scrollTargetPosition.top : scrollTargetPosition.left) - pageScrollOffset);\n        // Calculate the distance we need to go in total\n        pageScrollInstance.distanceToScroll = pageScrollInstance.targetScrollPosition - pageScrollInstance.startScrollPosition;\n        if (isNaN(pageScrollInstance.distanceToScroll)) {\n            // We weren't able to find the target position, maybe the element does not exist?\n            if (this.config._logLevel >= 2 || (this.config._logLevel >= 1 && isDevMode())) {\n                console.log('Scrolling not possible, as we can\\'t find the specified target');\n            }\n            pageScrollInstance.fireEvent(false);\n            return;\n        }\n        // We're at the final destination already\n        // OR we need to scroll down but are already at the end\n        // OR we need to scroll up but are at the top already\n        const allReadyAtDestination = Math.abs(pageScrollInstance.distanceToScroll) < pageScrollInstance.pageScrollOptions._minScrollDistance;\n        // Check how long we need to scroll if a speed option is given\n        // Default executionDuration is the specified duration\n        pageScrollInstance.executionDuration = pageScrollInstance.pageScrollOptions.duration;\n        // Maybe we need to pay attention to the speed option?\n        if ((pageScrollInstance.pageScrollOptions.speed !== undefined && pageScrollInstance.pageScrollOptions.speed !== null) &&\n            (pageScrollInstance.pageScrollOptions.duration === undefined || pageScrollInstance.pageScrollOptions.duration === null)) {\n            // Speed option is set and no duration => calculate duration based on speed and scroll distance\n            pageScrollInstance.executionDuration =\n                Math.abs(pageScrollInstance.distanceToScroll) / pageScrollInstance.pageScrollOptions.speed * 1000;\n        }\n        // We should go there directly, as our \"animation\" would have one big step\n        // only anyway and this way we save the interval stuff\n        const tooShortInterval = pageScrollInstance.executionDuration <= pageScrollInstance.pageScrollOptions._interval;\n        if (allReadyAtDestination || tooShortInterval) {\n            if (this.config._logLevel >= 2 || (this.config._logLevel >= 1 && isDevMode())) {\n                if (allReadyAtDestination) {\n                    console.log('Scrolling not possible, as we can\\'t get any closer to the destination');\n                }\n                else {\n                    console.log('Scroll duration shorter that interval length, jumping to target');\n                }\n            }\n            pageScrollInstance.setScrollPosition(pageScrollInstance.targetScrollPosition);\n            pageScrollInstance.fireEvent(true);\n            return;\n        }\n        if (!pageScrollInstance.pageScrollOptions.scrollInView) {\n            const alreadyInView = pageScrollInstance.targetScrollPosition > pageScrollInstance.startScrollPosition &&\n                pageScrollInstance.targetScrollPosition <= pageScrollInstance.startScrollPosition + scrollRange;\n            if (alreadyInView) {\n                if (this.config._logLevel >= 2 || (this.config._logLevel >= 1 && isDevMode())) {\n                    console.log('Not scrolling, as target already in view');\n                }\n                pageScrollInstance.fireEvent(true);\n                return;\n            }\n        }\n        // Register the interrupt listeners if we want an interruptible scroll animation\n        if (pageScrollInstance.pageScrollOptions.interruptible) {\n            pageScrollInstance.attachInterruptListeners(this.onInterrupted);\n        }\n        // Let's get started, get the start time...\n        pageScrollInstance.startTime = new Date().getTime();\n        // .. and calculate the end time (when we need to finish at last)\n        pageScrollInstance.endTime = pageScrollInstance.startTime + pageScrollInstance.executionDuration;\n        pageScrollInstance.timer = setInterval((instance) => {\n            // Take the current time\n            const currentTime = new Date().getTime();\n            // Determine the new scroll position\n            let newScrollPosition;\n            let stopNow = false;\n            if (instance.endTime <= currentTime) {\n                // We're over the time already, so go the targetScrollPosition (aka destination)\n                newScrollPosition = instance.targetScrollPosition;\n                stopNow = true;\n            }\n            else {\n                // Calculate the scroll position based on the current time using the easing function\n                newScrollPosition = Math.round(instance.pageScrollOptions.easingLogic(currentTime - instance.startTime, instance.startScrollPosition, instance.distanceToScroll, instance.executionDuration));\n            }\n            if (this.config._logLevel >= 5 && isDevMode()) {\n                console.warn('Scroll Position: ' + newScrollPosition);\n            }\n            // Set the new scrollPosition to all scrollViews elements\n            if (!instance.setScrollPosition(newScrollPosition)) {\n                // Setting the new scrollTop/scrollLeft value failed for all ScrollViews\n                // early stop the scroll animation to save resources\n                stopNow = true;\n            }\n            // At the end do the internal stop maintenance and fire the pageScrollFinish event\n            // (otherwise the event might arrive at \"too early\")\n            if (stopNow) {\n                this.stopInternal(false, instance);\n            }\n        }, this.config._interval, pageScrollInstance);\n        // Register the instance as running one\n        this.runningInstances.push(pageScrollInstance);\n    }\n    scroll(options) {\n        this.start(this.create(options));\n    }\n    /**\n     * Stop all running scroll animations. Optionally limit to stop only the ones of specific namespace.\n     */\n    stopAll(namespace) {\n        if (this.runningInstances.length > 0) {\n            let stoppedSome = false;\n            for (let i = 0; i < this.runningInstances.length; ++i) {\n                const pageScrollInstance = this.runningInstances[i];\n                if (!namespace || pageScrollInstance.pageScrollOptions.namespace === namespace) {\n                    stoppedSome = true;\n                    this.stopInternal(true, pageScrollInstance);\n                    // Decrease the counter, as we removed an item from the array we iterate over\n                    i--;\n                }\n            }\n            return stoppedSome;\n        }\n        return false;\n    }\n    stop(pageScrollInstance) {\n        return this.stopInternal(true, pageScrollInstance);\n    }\n}\nPageScrollService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.0.6\", ngImport: i0, type: PageScrollService, deps: [{ token: NGXPS_CONFIG }], target: i0.ɵɵFactoryTarget.Injectable });\nPageScrollService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.0.6\", ngImport: i0, type: PageScrollService, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.0.6\", ngImport: i0, type: PageScrollService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [NGXPS_CONFIG]\n                }] }]; } });\n\nclass NgxPageScrollCoreModule {\n    static forRoot(config) {\n        return {\n            ngModule: NgxPageScrollCoreModule,\n            providers: [PageScrollService, { provide: NGXPS_CONFIG, useValue: config }],\n        };\n    }\n}\nNgxPageScrollCoreModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.0.6\", ngImport: i0, type: NgxPageScrollCoreModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxPageScrollCoreModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"14.0.6\", ngImport: i0, type: NgxPageScrollCoreModule });\nNgxPageScrollCoreModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"14.0.6\", ngImport: i0, type: NgxPageScrollCoreModule, providers: [\n        PageScrollService,\n        { provide: NGXPS_CONFIG, useValue: {} },\n    ] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.0.6\", ngImport: i0, type: NgxPageScrollCoreModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    providers: [\n                        PageScrollService,\n                        { provide: NGXPS_CONFIG, useValue: {} },\n                    ],\n                }]\n        }] });\n\n/*\n * Public API Surface of ngx-page-scroll-core\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NGXPS_CONFIG, NgxPageScrollCoreModule, PageScrollInstance, PageScrollService, defaultPageScrollConfig };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}